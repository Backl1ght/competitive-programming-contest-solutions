# Codeforces Round #764 (Div. 3)

[比赛链接](http://codeforces.com/contest/1624)

## A. Plus One on the Subset

$\max\{a\} - min \{a\}$即为答案。

## B. Make AP

假设对$a$进行唯一的操作，那么$b, c$的值是确定的，修改后$a$的值也可以通过等差数列的性质计算出来，即为$a^\prime$，然后就看$a$是否能被$a^\prime$整除。

注意$m$是正整数，所以还要加一个判断。

$b, c$同理，任意一个可行即可。

## C. Paint the Array

不妨先将所有数都通过给定操作搞到$n$以内。

现在从大到小枚举，假设枚举到$i$，由于最终要的是一个排列，所以如果$a$中有多个$i$，保留一个即可，其余的都再操作一次；如果没有$i$，由于之前的操作，此时$a$中也没有别的数能够通过操作转换成$i$，无解。

## D. Palindromes Coloring

对于一个回文串，两边的字符都出现了两次，如果回文串长度为奇数，那么中间有一个单独的字符。

统计$s$中成对出现的字符的对数$e$，和剩余字符的个数$o$。

先只考虑两边的字符，中间的字符可以后面再加，易得此时最短的回文串长度为$2\lfloor \dfrac{e}{k} \rfloor$。

然后由于要的答案是最小长度，所以没用上的字符对也没必要用，此时，还有$2(e \mod k) + o$个字符没用，这些字符可以作为中间那个单独的字符。

如果$2(e \mod k) + o \ge k$，那么就可以给每一个回文穿加上中心。

## E. Masha-forgetful

一开始想到后缀数组拼起来然后乱搞（现在想想好像也不可行），写了一半发现了个性质。。。

长度大于等于2的串一定可以由零或多个长度为2和零或多个长度为3的串拼起来。

然后就是简单DP了。

## F. Interacdive Problem

二分。

假设现在要猜的区间是$[l, r]$，令$mid = \lfloor \dfrac{l + r}{2} \rfloor$。

令$N$为大于$r$且最小的$n$的倍数，$c$为$N - (mid + 1)$，如果操作之前$x \in [l, mid]$，返回的值不会变；如果操作之前$x \in [mid + 1, r]$，返回的值会比之前大1。

所以操作之后$x$的范围就会是$[l + c, mid + c]$和$[mid + 1 + c, r + c]$其中之一具体是哪一个看返回值是否改变，每次询问可以使$x$的可能取值个数减半。

## G. MinOr Tree

最小或生成树。。。

贪心加并查集。。。

首先把权值看成二进制数，然后先将答案置为全1，然后从高到低枚举每一个位，看这个位能不能为0，能为0就把答案的这个位置零。

如何判断一个位是否能为0呢？枚举所有边，看能不能用满足条件的边联通所有点：边的权值的对应位不为1且加入这条边不会使答案变大（即权值或上此时的答案还是答案）。如果可以就说明答案的对应位可以为0。