# Codeforces Round #780 (Div. 3)

[比赛链接](http://codeforces.com/contest/1660)

## A. Vasya and Coins

$a=0$就是1,否则就是$a + 2b + 1$。

## B. Vlad and Candies

$n=1$特判。

最大值大于次大值加一则无解，不然有解。

## C. Get an Even String

感觉写复杂了。。。

一个字符，要么被删了，要么是连续两个相同字符的第一个，要么是第二个。

然后就动态规划，对于第$i$个字符，删掉和作为前一个字符这两个可以直接从$dp_{i-1}$转移得到，作为后一个字符的话就是从上一个相同字符的地方$p_i$转移过来，因为找上上个的话不可能更优。

## D. Maximum Product Strikes Back

如果包含$0$的话，则乘积一定是$0$，所以以$0$为分隔把原序列划分为多个连续子序列，每个连续子序列都不包含$0$。

然后$1$其实对答案没有贡献的，忽略。

把连续子序列中，$2$和$-2$的个数算出来，然后乘积的正负算出来。

如果是正的，那么就可以直接用来更新答案，因为去掉元素并不会比现在更好。

要么就是还需要找到一个负数，然后删掉。因为只需要一个，所以要么删头，要么删尾，直接枚举就行了。

## E. Matrix and Shifts

原本在一条主对角线上的元素，循环移位后还是会在一个主对角线上，所以4个循环移位操作并不会改变结果，忽略。

然后就是枚举每一条主对角线然后算答案了。

## F1. Promising String (easy version)

假设子串有$a$个`+`和$b$个`-`，那么子串是promising当且仅当$b \ge a$且$b - a \equiv 0 \mod 3$。

直接前缀和结合$o(n^2)$暴力枚举过了。。。

## F2. Promising String (hard version)

假设现在考虑了前$i$个元素，包含$a_i$个`+`和$b_i$个`-`，令$p_i = b_i - a_i$。

对于$i < j$，当且仅当$p_i \equic p_j \mod 3$时，满足第二个条件。

现在还需要满足第一个条件，也就是$b_j - b_{i - 1} > a_j - a_{j - 1}$，其实就是$p_j > p_{i - 1}$。

可以维护3个平衡树，分别维护3个模3等价类，这样查询和修改都可以只针对一棵平衡树，修改就是插入$p_i$，查询就是查询平衡树内小于等于$p_i$的数的个数。都是平衡树的基本操作。