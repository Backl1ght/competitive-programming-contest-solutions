# Educational Codeforces Round 126 (Rated for Div. 2)

[比赛链接](https://codeforces.com/contest/1661)

## A. Array Balancing

如果$a_i > b_i$，那么就对换，反之不对换。

## B. Getting Zero

一开始写递归发现死循环了，改成写BFS就能过。

## C. Water the Trees

最后的状态会是所有元素都等于初始状态所有元素中的最大值。

然后二分。

## D. Progressions Covering

从后往前删，每次让最后一个$a_i < b_i$的位置的$a_i$加$k$，这样会是最优的。

然后就是怎么维护的问题了，假设当前位于$i$，之前在位置$j >= i$操作了$p_j$次，$[i, i + k - 1]$内共操作了$count$次，这些操作对当前位置的影响为$a_i = a_i  +delta$，如果$a_i < b_i$且$i > k$，就让$a_i$加$k$一直加到$a_i \ge b_i$。

位置$i$操作完了就移动到位置$i - 1$，对于位置$i - 1$，$[i, i + k - 1]$所有操作的影响都减了$1$，所以$delta = delta - count$，然后$p_{i + k -1}$不再有影响，所以$count = count - p_{i + k - 1}$。重复上一个操作。

注意对于$1 \le i \le k$，内的元素，此时可能还不满足条件，这个时候只能令$a_k$去加$k$，还需要的操作数很容易就能算。

## E. Narrow Components

线段树经典题型，比赛的时候想出来了，但是手残半个小时没调出来，主要是合并区间的操作没写好。

其实就是线段树维护，每次合并左右两个区间的时候，左区间的右边界和右区间的左边界可能会连通，从而减少连通块的数量，所以左右区间合并的时候，先把两个区间的答案加起来，再讨论减少的情况。

有一个方法可以比较好的维护：对原本矩阵中的方格进行编号，然后对于每个区间维护3个值：区间答案$ans$，3个左边界编号$lmask$，3个右边界编号$rmask$。然后合并的时候就是并查集加边，如果$lmask_i$和$rmask_i$都是有效的点，那么他们之间可以加边，如果成功加边就会使连通块数量减1。

## F. Teleporters

TBA。
