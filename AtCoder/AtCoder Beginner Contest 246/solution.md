# AtCoder Beginner Contest 246

[比赛链接](https://atcoder.jp/contests/abc246)

## A - Four Points

对于横座标，矩形的4个点会有2个不同取值，分别有两个，给出其中3个，那么将这3个数异或起来就是剩下的那个值。

纵座标同理。

## B - Get Closer

输出向量$(A, B)$的单位向量即可。

## C - Coupon

首先，如果有多个商品的价格大于等于$X$，那么把优惠券用在哪一个商品都是一样的，扫一遍预处理掉这部分。

现在，所有商品的价值都是小于$X$的了，现在对某一个商品用优惠券相当于这个商品就免费了，所以排个序优先选择价值大的商品使用优惠券。

## D - 2-variable Function

首先，注意到由于立方项的存在，$a$和$b$的取值至多就是$10^6$。

枚举$a$这一维，剩下$b$这一维是单调函数，可以二分找到使结果大于$N$且最小的$b$的取值。

这样所有的可能性都考虑到了，取其中最小即可。

## E - Bishop 2

BFS板子，就下一步的方向和当前方向相同则代价不增加。

## F - typewriter

首先，有$a$个不同字母，长度为$l$的串，有$a^l$种。

然后，多行之间的答案可能有重复，重复的部分就是它们的并集，而这个并集是有每行字母的并集生成的，很容易想到容斥原理。

由于$n$最大只有18，直接暴力枚举然后容斥就可以了。

## G - Game on Tree 3

首先，可以看出答案满足单调性，所以可以二分做。

假设现在枚举到的答案是$x$，那么只需要能走到一个大于等于$x$的点然后结束游戏，就可行。不妨将点分为两类，一类小于$x$，一类大于等于$x$，那么后手玩家的操作就变成了把第二类的节点转成第一类的。考虑使用动态规划判断是否可行。

记$dp_u$表示走到$u$之前，$u$的子树中最少需要多少操作，才能让先手玩家无法在$u$的子树中赢得游戏。对于叶子节点其取值显然是1，且如果$dp_{root} \ne 0$则说明先手方可以获得大于等于$x$的结果。

对于$u$这个节点，首先$u$自身可能需要耗费操作，$a_u < x$的话就可以不操作$u$，$a_u \ge x$的话那必须操作$u$。

然后，$u$往子树走的这一步可以用来完成一个操作，这一个操作只可以用在处理$u$的子树，不包括$u$。

最后就是子树中需要的操作也可能需要在进入$u$之前就完成，然后除了上一步说到的那一个操作之外，其余$u$的子树中的操作也需要在进入$u$之前完成。

这样就有

$$
dp_u = [a_u \ge x] + \max(0, -1 + \sum_{v is child of u} dp_v)
$$

## Ex - Product Modulo 2

如果不考虑修改的话就是个简单dp，看是以`0`还是以`1`结尾。

带修改的话很容易想到线段树之类的数据结构，然后就是线段树单点修改，全局询问了。

因为其实把dp的转移方程写出来的话，可以发现$dp_i$其实就是$dp_{i - 1}$的线性组合，可以写成矩阵乘的形式，然后矩阵乘是有结合律的，所以就可以线段树维护。