# AtCoder Beginner Contest 320

## [F - Fuel Round Trip](https://atcoder.jp/contests/abc320/tasks/abc320_f)

自己想到了维护一条正向的，一条反向的，但距离正解还是差一点。

考虑 DP 。

$dp(i, x, y)$ 表示正着走走到 $i$ 时剩下 $x$ 单位体积的油，倒着走走到 $i$ 时剩下 $y$ 单位体积的油，的最小代价。特别地， $x$ 是加油后的油量， $y$ 是加油前的油量。（正着走的时候是从 $i - 1$ 走到 $i$ ，看是否加油，在从 $i$ 走到 $i + 1$ ；倒着走的时候需要反过来，相当于减油）

从 $i$ 转移到 $i + 1$ ，不加油：可以从 $dp(i, x, y)$ 转移到 $dp(i + 1, x - d, y + d)$ 。

然后考虑加油的情况：

正着走的加油：可以从 $dp(i + 1, x, y)$ 转移到 $dp(i + 1, \min(H, x + f_i), y)$ 。

倒着走的加油：$y \ge f_i$ 时，可以从 $dp(i + 1, x, y)$ 转移到 $dp(i + 1, x, y - f_i)$ ； $y + f_i \ge H$ 时，可以从 $dp(i + 1, x, H)$ 转移到 $dp(i + 1, x, y)$。

## [G - Slot Strategy 2 (Hard)](https://atcoder.jp/contests/abc320/tasks/abc320_g)

把 $T$ 时间内的时间看成点，把机器看成点，然后枚举最后机器显示的数字，某个时间某个机器显示对应数字看成一条容量为 $1$ 的边，那么这个图的最大流就是 $T$ 时间内，最多能让多少台机器显示对应数字。

当且仅当 $s_i$ 包含 $d$ ，我们才能让机器 $i$ 显示 $d$ ，然后最差的情况下就是所有 $s_i$ 中都只包含一个 $d$ 而且还是在同一个位置，这种情况下需要跑 $n$ 轮，每轮 $m$ 时间，所以如果有解最差也能在 $nm$ 时完成。

然后对于每个数字，每台机器，我们最多考虑 $n$ 个不同的时间就足够了（鸽巢原理？）。由此，至多有 $n^2$ 条边，用 Dinic 跑最大流的复杂度在 $O(n^3)$ 。

> 在单位容量的网络中，Dinic 算法的增广轮数是 $O(|E|^{\frac{1}{2}})$ 的。 https://oi-wiki.org/graph/flow/max-flow/

总的时间复杂度为 $O(nm + n^3d\log(nm))$ 。
